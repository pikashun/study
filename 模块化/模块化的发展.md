<!--
 * @Author: your name
 * @Date: 2021-04-12 03:29:01
 * @LastEditTime: 2021-04-18 15:30:30
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \site\前端学习\笔记\模块化\模块化的发展.md
-->
# JS 发展的几个阶段
    1阶段，最初仅仅用于实现页面中的小效果，语言本身的缺陷被大家忽略
    2阶段，ajax的出现改变了JS在浏览器中的角色，让JS可以和服务器之间进行交互，但存在以下问题，限制了前端的规模
        浏览器执行JS的速度太慢
        用户端的电脑配置不足
        更多的代码带来了全局变量污染，依赖关系混乱等问题
    3阶段，谷歌发布V8引擎，技术发展，2阶段中前两个约束消失
    4阶段，实现模块化；

# common.js
    nodejs直接运行某个js文件，该文件称为入口文件
    nodejs遵循ES标准，可以使用ES的语法和api，但脱离了浏览器环境无法使用浏览器提供的api

## commonJS
    在nodeJS中，由于只有一个入口文件，所以需要模块化，由于刚开始没有官方标准，所以采用社区标准，commonJS

    模块 ： 
        模块就是一个JS文件，它实现了一部分功能，并隐藏自己的内部实现，同时提供了一些接口供其他模块使用
        模块的两个核心要素 ： 隐藏和暴露，隐藏的是自己的内部实现，暴露的是对外提供的接口

        正常的模块化标准，都应该默认隐藏模块中的所有实现，而通过一些语法或api调用来暴露接口

    模块的导入导出：
        暴露接口的过程就是模块的导出
        通过某种语法或api去使用一个模块时，这个过程叫模块的导入

## commonJS规范
    commonJS使用exports导出模块，require导入模块
    具体规范如下 ： 
        1，如果一个JS文件中存在exports或require，该JS文件是一个模块

        2，模块内的所有代码均为隐藏代码，包括全局变量，全局函数，这些全局的内容均不应该对全局变量造成任何污染

        3，如果一个模块需要暴露一些api提供给外部使用，需要通过exports导出，exports是一个空的对象，可以为该对象添加任何需要导出的内容，

        4，如果一个模块需要导入其他模块，通过require实现，require是一个函数，传入模块的路径即可返回该模块导出的整个内容

    
    nodeJD对CommonJS的实现：
        为了实现common JS的规范,nodeJS对模块做出了以下处理
            1，为了保证高效的执行，仅加载必要的模块，nodeJS只有执行到了requir函数时才会加载并执行模块
            2，为了隐藏模块中的代码，nodeJS执行模块时，会将模块中的所有代码放置在一个函数中执行，以保证不会污染全局变量
            3，为了保证顺利的导出模块内容，nodeJS做了如下处理
                1，在模块开始执行前，初始化一个值，module.exports = {}
                2，module.exports即模块的导出值
                3，为了方便开发者便捷的导出，nodeJS在初始化完module.exports后，又声明了一个变量exports = module.exports
            4，为了避免反复加载同一个模块，nodeJS默认开启了模块缓存，如果加载的模块已经被加载过了，则会自动使用之前的导出结果
               由于缓存，模块里的全局代码只会执行一次

# 浏览器端模块化的难题

## commonJS的工作 原理
    当使用require(模块路径)导入一个模块时，node会做以下两件事(不考虑模块缓存)，
        1，通过模块路径找到本机文件，并读取文件内容
        2，将路径中的代码放入到一个函数环境中执行，并将执行后module.exports的值作为require函数的返回结果
    正是这两个步骤，使得commonJS在node端可以良好的被支持

    可以认为，commonJS是同步的，必须要等到加载完文件并执行完代码后才能继续向后执行；

    当要把commonJS放到浏览器端时，就遇到了一些挑战
        1，浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率，由于commonJS时同步的，这会极大的降低运行性能

        2，如果需要读取JS文件内容并把它放入一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是commonJS属于社区标准，并非官方标准
## 新的规范
    基于以上两点原因，浏览器无法支持模块化
    可这并不代表模块化不能在浏览器中实现
    要在浏览器中实现模块化，只要能解决上面的两个问题就行了
    解决办法：
        1，既然远程加载JS浪费了时间，做成异步即可，加载完成后调用一个回调就行；
        2，既然模块中的代码需要放置到函数中执行，编写模块时直接放在函数中即可，

    基于这种思路，出现了AMD和CMD规范，解决了浏览器模块化的问题。


# AMD规范
    全称是Asynchronous Module Definition，即异步模块加载机制
    
    require.js实现了AMD规范

    在AMD中导入和导出模块的代码，都必须放置在define函数中

# CMD规范
    全称时，Common Module Definition，公共模块定义规范

    sea.js实现了CMD规范

    在CMD中，导入和导出模块的代码，都必须放置在define函数中

    define(function (require,exports,module){
        //模块内部代码；
    })
