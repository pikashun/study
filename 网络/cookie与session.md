# cookie与session
    若用JS变量存储数据，则页面关闭时，数据会消失

## cookie

    可以跨页面，存储在浏览器中，
    cookie有限制，只能用于自己的域名下
    可以长期存储
    cookie即使是保存在浏览器里，也是存放在不同域名下的

### 具体过程
    1，初始状态，未登录
    2，访问百度的登录，输入用户名，密码
    3，如果用户名和密码是正确的，百度的后端会向这个域名下，设置一个cookie。写入用户的基本信息；（加密的）；
    4，以后每一次向百度发送请求，浏览器会自动带上这些cookie
    5，服务器（看到）了带有ID的cookie，就可以解析这个加密的ID，来获取这个用户本身的ID，
    6，如果能获取到本身的ID，那么就证明这个用户已经登录过了，所以后端可以继续保留用户的信息

    缺点，若cookie被复制了，则可以在其他电脑登录账号，

## session
    信息存在服务器端，本地没有
    但若用户量比较大时，服务器资源消耗大
    因为后端可能不仅仅存在一台服务器，用户信息一般只存在一台服务器上，因为用户的登录操作，在那台机器上执行，就一般存在哪台服务器上，需要通过反向代理（轮询，IP哈希）

# 页面正确打开方式

## B/S,C/S结构
    client/server；客户端/服务器
    client只负责内容的展示，server负责提供内容
    browser/server;浏览器/服务器
    browse只负责内容展示，server提供服务


### B/S结构具体过程
    index.html
    本质是一个字符串，带有html格式的字符串
    向服务器发送请求的本质
    1，发送请求到www.baidu.com
    2，服务器接收到请求之后，把这个页面的内容（html）格式的字符串返回给浏览器；
    3，页面的字符串存在HTML文件里，例如index.html;
    4，服务器端需要读取文件，
    5，服务器将取出来的文件发送给浏览器；

    最后返回的是一个字符串，这个字符串的来源可能是文件，可能是缓存，也可能来自于数据库


    服务器：严格来说就是一台计算机，只提供服务。但是，常说的服务器指的是服务容器，而不是服务器

    服务容器： 是一个程序，程序可以监听一个端口；一个端口只有一个程序去监测。可以读取文件并且返回；

    如果想通过访问服务器的方式访问自己写的页面；可以装一个服务容器的程序。

# 发送网络请求
    1，浏览器地址栏直接网址输入
    2，location.href="url"   //location.href="http://www.baidu.com",但页面会发生跳转，勾选preserve log可以保留之前发送的请求，不选则清除；
    3，带有src属性的标签。可发送请求，服务器端可以处理并返回数据，但浏览器不一定能接收；
    4，带有href属性的标签。可发送请求，服务器端可以处理并返回数据，但浏览器不一定能接收
    5，带有action属性的标签，action="url",发送请求之后页面也会跳转。
    6，ajax，可以用代码控制，页面不会跳转，服务器端返回的结果可以用js继续处理


## ajax
    //请求要素：
        // 1，请求方式：get，POST
        // 2，url
    var xhr = null;
    if(window.XMLHttpRequest){
        xhr = new XMLHttpRequest();
    }else{
        xhr = new ActiveXObject("Microsoft.XMLHttp");//兼容IE6；
    }
    //新建ajax 此时xhr.readyState值为0
    xhr.open('get','http://www,baidu.com',true) //http://developer.duyiedu.com/edu/testAjax   //初始化链接，建立与服务器之间的链接，此时xhr.readyState值为1,第三个参数true表示异步，false表示同步；
    xhr.onreadystatechange = function () {
        //xhr.readyState值发生改变时会执行，值为4时表示请求完，已接收到数据
        if(xhr.onreadyState === 4 && xhr.status === 200){
            //网络请求，结果都会有一个状态码，来表示这个结果是否正常，200表示请求成功，3xx表示重定向，接口改变，浏览器接收后会根据返回信息重新请求;4xx表示客户端错误，5xx表示服务端错误
            console.log(xhr.responseText);//xhr.responseText代表，返回的数据，返回为JSON格式
            var data = JSON.parse(xhr.responseText);//转化为对象
        }
    }
    xhr.send();//发送过程xhr.readyState不变，发送完毕会改变，


# 跨域

## 跨域访问资源 
    资源：JS文件是资源，但JS文件允许被跨域请求；css，jpg png等都允许；src属性的资源都可以被跨域请求；href大部分可以被跨域请求

    算跨域请求的资源： 后端接口的数据；其他域的cookie；其他域的缓存

    其他域：
        页面本身：协议+域名+端口
        议，域名，端口号有任何一个不一样就算跨域
    
    跨域行为发生在浏览器接收数据是发现当前页面的域与请求的域不同，所以判断为跨域，所以浏览器不会吧结果传给代码；

### 解决跨域问题
    1，后端是否配合进行跨域
        pan.baidu.com --> zhidao.baidu.com
        解决办法：1，JSONP：正常情况下返回数据是JSON格式，JSONP是一种特使格式
                 2，后端设置Access-control-Allow—Origin属性以支持跨域

    2，后端不配合
        1，iframe进行跨域：<iframe src="url"></iframe>;只能显示，不能控制
        2，通过后端代理（自己的后端）；

# JSONP

    因为想从接口获取一个数据，但接口跨域，但接口支持JSONP

    script标签，有src属性，可以发送网络请求，还可以跨域，但浏览器会当做JS文件，默认执行

    JSONP原理，
    1，判断请求与当前域是否同源，若同源，则发送正常的ajax，没有跨域
    2，若不同源，则生成一个script标签，
    2，随机生成一个callback名字，并创建方法。
    4，设置script标签的src，设置为要请求的接口，
    5，将callback作为参数拼接在后面。
    //============以上是前端部分=========
    6，后端收到请求后，开始准备要返回的数据，
    7，后端拼接数据，将要返回的数据用callback的值和括号包起来，
            例如：callback=asd123455,要返回的数据为{"a" : 1,"b" : 2}
                 就要拼接为asd123455({"a" : 1,"b" : 2});
    8，然后将内容返回
    //============以上是后端部分==========
    9，浏览器接收到内容，会当做JS代码来执行，
    10，从而执行名为asd123455的方法，这样就接收到了后端返回给我们的对象。
